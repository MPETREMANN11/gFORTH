\ ***********************************************************************
\ ESP32 Disassembler                                                    *
\    Filename:      Disassembler.txt                                    *
\    Date:          28.05.2021                                          *
\    MCU:           ESP32 -- gForth                                     *
\    Copyright:     Marc PETREMANN                                      *
\    Author:        Marc PETREMANN                                      *
\    Updated:       02.06.2021                                          *
\ ***********************************************************************

\ assembly instructions for ESP32 are taken from this document:
\ https://github.com/MPETREMANN11/gFORTH/blob/master/meta/esp32/xtensa.pdf

vocabulary ESP32disassembler
ESP32disassembler definitions
only forth also
ESP32disassembler also
forth

\ Instructions format: ( pages 593... Xtensa.pdf )
\ RSR
\ RRI4
\ CALLX
\ RRRN
\ RI16
\ RI7...


\ Registers
\ AR    address registers
\ PC    program counter
\       special registers (p 233 Xtensa.pdf)
\           0   LBEG
\           1
\           2
\           3
\           4
\           5
\           12
\           15
\           16
\           17

\ The ESP32 has 16 registers (actually more once you get involved with the register window 
\ business, but never mind that for now. They are designated a0 through a15.
\ Two of them are special. a0 is used for subroutine return addresses. a1 is the stack pointer. 
\ You can use these as general registers as long as you understand what you are doing. 


\ Use the RUR.* and WUR.* instructions to access the user registers.
\       user registers (p261 Xtensa pdf)
\           0..223
\           231     THREADPTR
\           232     FCR
\           233     FSR



\ souyrce: http://cholla.mmto.org/esp32/bootrom/disasm.html
\ Instructions are either 16 or 24 bits in size, but you rarely care about that. This is a RISC 
\ machine with a load/store architecture. Data flow in the assembler syntax used is right to left, 
\ with some exceptions (notably the s32i instruction). Think of it like an assignment statement in C. 
\ Here are some examples:
\     movi    a0, 0		; a0 = 0
\     and	    a3, a3, a2		; a3 = a3 & a2
\     sub     a13, a13, a14	; a13 -= a14
\     l32i.n  a3, a2, 0		; a3 = *a2
\     s32i.n  a3, a2, 0		; *a2 = a3
\     addi    a8, a4, -1		; a8 = a4 - 1

\ The l32r instruction fetches a 32 bit constant that is stored (dumped) someplace 
\ nearby (hence the actual address where the constant is dumped is of little real 
\ interest).
\ l32r    a3, [0x0000abab]	; a3 = 0x0000abab


\ **** My firsts ESP32 dissambling words ************************************

\ get op0 from addr
\ : @op2 { addr -- op0 }
\     addr cell+ @                \ get op0
\     ;

\ get op1 from addr
\ : @op1 { addr -- op0 }
\     addr cell+ cell+ @          \ get op1
\     ;

\ get op0 from addr
\ : @op0 { addr -- op0 }
\     addr cell+ cell+ cell+ @    \ get op2
\     ;

\ get op0 op1 op2 from addr
\ : @op012 { addr -- op0 op1 op2 }
\     addr @op0    \ get op0
\     addr @op1    \ get op1
\     addr @op2    \ get op2
\     ;


\ +------------------------------------------------------------------------+
\ Instructions format: ( pages 593... Xtensa.pdf )

\ RRR         23      19      15      11       7       3     0
\             +-------+-------+-------+-------+-------+-------+
\ Little End. |  op2  |  op1  |   r   |   s   |   t   |  op0  |
\             +-------+-------+-------+-------+-------+-------+

\ transform op0 op1 and op2 in a 24 bits mask
: >RRR  { op2 op1 ar as at op0 }
    #3 ,                    \ compile length
    op0
    at   4 lshift  or
    as   8 lshift  or
    ar  12 lshift  or
    op1 16 lshift  or
    op2 20 lshift  or  ,
    ;

: @mask  ( addr --- mask )
    cell+ @
    ;


\ length in byte of instruction
: RRR: ( comp: op2 op1 ar  as  at op0 -- | exec: -- mask )
    create
        >RRR
        s" RRR" swap , ,
    does>
        @mask
    ;




\ Example:
\  op2   op1    r     s     t    op0
\ %0110 %0000 %0000 %0001 %0000 %0000  RRR: ABS



\ +------------------------------------------------------------------------+
\ Instructions format: ( pages 596... Xtensa.pdf )

\ RRRN        15      11       7       3     0
\             +-------+-------+-------+-------+
\ Little End. |   r   |   s   |   t   |  op0  |
\             +-------+-------+-------+-------+

: >RRRN { r s t op0 -- mask }
    #2 ,                    \ compile length
    op0
    t   4 lshift  or
    s   8 lshift  or
    r  12 lshift  or  ,
    ;

: RRRN: ( comp: op0 length -- | exec: -- )
    create
        >RRRN
        s" RRRN" swap , ,
    does>
        @mask
    ;

\ Example:
\   r     s     t    op0
\ %0000 %0000 %0000 %1010  RRRN: ADD.N                 \ Narrow Add



\ +------------------------------------------------------------------------+
\ Instructions format: ( pages 595... Xtensa.pdf )

\ CALL        23                                   5  3     0
\             +-------+-------+-------+-------+---+---+-------+
\ Little End. |              offset               | n |  op0  |
\             +-------+-------+-------+-------+---+---+-------+


: >CALL  { n op0 }
    #3 ,                    \ compile length
    op0
    n    4 lshift  or  ,
    ;

: CALL: ( comp: n op0 -- | exec: -- mask )
    create
        >CALL
        s" CALL" swap , ,
    does>
        @mask
    ;

\ Example:
\              n   op0
\             %00 %0000  CALL: CALL0


\ +------------------------------------------------------------------------+
\ Instructions format: ( pages 595... Xtensa.pdf )

\ CALLX       23       19      15      11      7   5  3     0
\             +-------+-------+-------+-------+---+---+-------+
\ Little End. |  op2  |  op1  |   r   |   s   | m | n |  op0  |
\             +-------+-------+-------+-------+---+---+-------+


: >CALLX  { op2 op1 ar as m n op0 }
\ break" >callx : "
    #3 ,                    \ compile length
    op0
    n    4 lshift  or
    m    6 lshift  or
    as   8 lshift  or
    ar  12 lshift  or
    op1 16 lshift  or
    op2 20 lshift  or  ,
    ;

: CALLX: ( comp: op2 op1 ar as m n length -- | exec: -- mask )
    create
        >CALLX
        s" CALLX" swap , ,
    does>
        @mask
    ;

\ Example:
\  op2   op1     r     s   m   n   op0
\ %0000 %0000 %0000 %0000 %11 %00 %0000  CALLX: CALLX0





%0110 %0000 %0000 %0001 %0000 %0000  RRR: ABS           \ Absolute Value
%1111 %1010 %0000 %0000 %0001 %0000  RRR: ABS.S         \ Absolute Value Single
%1000 %0000 %0000 %0000 %0000 %0000  RRR: ADD           \ Add
%0000 %0000 %0000 %1010  RRRN: ADD.N                    \ Narrow Add
%0000 %1010 %0000 %0000 %0000 %0000  RRR: ADD.S         \ Add Single
\ ADDI
%0000 %0000 %0000 %1011  RRRN: ADDI.N                   \ Narrow Add Immediate
\ ADDMI
%1001 %0000 %0000 %0000 %0000 %0000  RRR: ADDX2         \ Add with Shift by 1
%1010 %0000 %0000 %0000 %0000 %0000  RRR: ADDX4         \ Add with Shift by 2
%1011 %0000 %0000 %0000 %0000 %0000  RRR: ADDX8         \ Add with Shift by 3
%0000 %0000 %1001 %0000 %0000 %0000  RRR: ALL4          \ All 4 Booleans True
%0000 %0000 %1011 %0000 %0000 %0000  RRR: ALL8          \ All 8 Booleans True
%0001 %0000 %0000 %0000 %0000 %0000  RRR: AND           \ Bitwise Logical And
%0000 %0010 %0000 %0000 %0000 %0000  RRR: ANDB          \ Boolean And
%0001 %0010 %0000 %0000 %0000 %0000  RRR: ANDBC         \ Boolean And with Complement
%0000 %0000 %1000 %0000 %0000 %0000  RRR: ANY4          \ Any 4 Booleans True
%0000 %0000 %1010 %0000 %0000 %0000  RRR: ANY8          \ Any 8 Booleans True
\ BALL
\ BANY
\ BBC
\ BBCI
\ BBCI.L
\ BBS
\ BBSI
\ BBSI.L
\ BEQ
\ BEQI
\ BEQZ
\ BEQZ.N
\ BF
\ BGE
\ BGEI
\ BGEU
\ BGEUI
\ BGEZ
\ BLT
\ BLTI
\ BLTU
\ BLTUI
\ BLTZ
\ BNALL
\ BNE
\ BNEI
\ BNEZ
\ BNONE
%0000 %0000 %0100 %0000 %0000 %0000  RRR: BREAK         \ Breakpoint %0100 b12..b15
\ BT
%00 %0101  CALL: CALL0             \ Non-windowed Call
%01 %0101  CALL: CALL4             \ Call PC-relative, Rotate Window by 4
%10 %0101  CALL: CALL8             \ Call PC-relative, Rotate Window by 8
%11 %0101  CALL: CALL12            \ Call PC-relative, Rotate Window by 12

%0000 %0000 %0000 %0000 %11 %00 %0000  CALLX: CALLX0    \ Non-windowed Call Register
%0000 %0000 %0000 %0000 %11 %01 %0000  CALLX: CALLX4    \ Call Register, Rotate Window by 4
%0000 %0000 %0000 %0000 %11 %10 %0000  CALLX: CALLX8    \ Call Register, Rotate Window by 8
%0000 %0000 %0000 %0000 %11 %11 %0000  CALLX: CALLX12   \ Call Register, Rotate Window by 12


%1011 %1010 %0000 %0000 %0000 %0000  RRR: CEIL.S        \ Ceiling Single to Fixed
%0011 %0011 %0000 %0000 %0000 %0000  RRR: CLAMPS        \ Signed Clamp
\ DHI
\ DHU
\ DHWB
\ DHWBI
\ DII
\ DIU
\ DIWB
\ DIWBI
\ DPFL
\ DPFT
\ DPFRO
\ DPFW
\ DPFWO

%0000 %0000 %0010 %0000 %0011 %0000  RRR: DSYNC
\ ENTRY
\ ESYNC
\ EXCW
\ EXTUI
\ EXTW
\ FLOAT.S
\ FLOOR.S
\ IDTLB
\ IHI
\ IHU
\ III
\ IITLB
\ IIU
\ ILL
\ ILL.N
\ IPF
\ IPFL
\ ISYNC
\ J
\ J.L
\ JX
\ L8UI
\ L16SI
\ L16UI
\ L32AI
\ L32E
\ L32I
\ L32I.N
\ L32R
\ LDCT
\ LDDEC
\ LDINC
\ LICT
\ LICW
\ LOOP
\ LOOPGTZ
\ LOOPNEZ
\ LSI
\ LSIU
\ LSX
\ LSXU
\ MADD.S
\ MAX
\ MAXU
\ MEMW
\ MIN
\ MINU
\ MOV
\ MOV.N
\ MOV.S
\ MOVEQZ
\ MOVEQZ.S
\ MOVF
\ MOVF.S
\ MOVGEZ
\ MOVGEZ.S
\ MOVI
\ MOVI.N
\ MOVLTZ
\ MOVLTZ.S
\ MOVNEZ
\ MOVNEZ.S
\ MOVSP
\ MOVT
\ MOVT.S
\ MSUB.S
\ MUL.AA
\ MUL.AD
\ MUL.DA
\ MUL.DD
\ MUL.S
\ MUL16S
\ MUL16U
\ MULA.AA
\ MULA.AD
\ MULA.DA
\ MULA.DD
\ MULL
\ MULS.AA
\ MULS.AD
\ MULS.DA
\ MULS.DD
\ MULSH
\ MULUH
\ NEG
\ NEG.S
\ NOP
\ NOP.N
\ NSA
\ NSAU
\ OEQ.S
\ OLE.S
\ OLT.S
\ OR
\ ORB
\ ORBC
\ PDLTB
\ PITLB
\ QUOS
\ QUOU
\ RDTLB0
\ RDTLB1
\ REMS
\ REMU
\ RER
\ RET
\ RET.N
\ RETW
\ RETW.N
\ RFFD
\ RFDE
\ RFDO
\ RFE
\ RFI \0..15
\ RFME
\ RFR
\ RFUE
\ RFWO
\ RFWU
\ RITBLB0
\ RITBLB1
\ ROTW
\ ROUND.S
\ RSIL
\ RSR.*
\ RSR
\ RSRat
\ RSYNC
\ RUR
\ RUR.*
\ S8I
\ S16I
\ S32C1I
\ S32E
\ S32I
\ S32I.N
\ S32RI
\ SDCT
\ SEXT
\ SICT
\ SICW
\ SIMCALL
\ SLL
\ SLLI
\ SRA
\ SRAI
\ SRC
\ SRL
\ SRLI
\ SSA8B
\ SSA8L
\ SSAI
\ SSI
\ SSIU
\ SSL
\ SSR
\ SSX
\ SSXU
\ SUB
\ SUB.S
\ SUBX2
\ SUBX4
\ SYSCALL
\ TRUNC.S
\ UEQ.S
\ UFLOAT
\ ULE.S     \ Compare Single Unord or Less Than or Equal
\ ULT.S     \ Compare Single Unordered or Less Than
\ UMUL.AA.* \ Unsigned Multiply
\ UN.S      \ Compare Single Unordered
\ UTRUNC.S  \ Truncate Single to Fixed Unsigned
\ WAITI     \ Wait for Interrupt
\ WDTLB     \ Write Data TLB Entry
%0100 %0000 %0111 %0000 %0000 %0000  RRR: WER           \ Write External Register
\ WFR       \ Move AR to FR
\ WITLB     \ Write Instruction TLB Entry
\ WSR.*
\ WSR       \ Write Special Register
\ WUR.*
\ WUR       \ Write User Register
%0011 %0000 %0000 %0000 %0000 %0000  RRR: XOR           \ Bitwise Logical Exclusive Or
\ XORB      \ Boolean Exclusive Or
\ XSR.*
\ XSR       \ Exchange Special Register










\ +------------------------------------------------------------------------+
\ Instructions format: ( pages 594... Xtensa.pdf )

\ RRI8        23              15      11       7       3     0
\             +-------+-------+-------+-------+-------+-------+
\ Little End. |     imm8      | 1100  |   s   |   t   |  0010 |
\             +-------+-------+-------+-------+-------+-------+

: (RRI8) { op0 -- mask }
    ;

: RRI8: ( comp: op0 op1 length -- | exec: -- )
    create
        , , ,
    does>
        (RRI8)
    ;

\ ADDI \ Add Immediate
\ ADDMI \ Add Immediate with Shift by 8
\ %0111 %0100  RRI8: BALL             \ Branch if All Bits Set




\  = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
include ESP32listINSTR.txt



